%include "boot.inc"


section loader vstart=LOADER_BASE_ADDR
   
;构建gdt及其内部的描述符
    GDT_BASE:   dd    0x00000000 
	            dd    0x00000000

    CODE_DESC:  dd    0x0000FFFF 
	            dd    DESC_CODE_HIGH4

    DATA_STACK_DESC:  dd    0x0000FFFF
		              dd    DESC_DATA_HIGH4

    VIDEO_DESC: dd    0x80000007
	            dd    DESC_VIDEO_HIGH4

    GDT_SIZE     equ   $ - GDT_BASE
    GDT_LIMIT    equ   GDT_SIZE -	1 
    
    times 60 dq 0					 ; 此处预留60个描述符的空位(slot)
    
    SELECTOR_CODE  equ (0x0001<<3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA  equ (0x0002<<3) + TI_GDT + RPL0	 ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	 ; 同上 

    ; total_mem_bytes用于保存内存容量,以字节为单位
    total_mem_bytes dd 0					 

    gdt_ptr  dw  GDT_LIMIT 
             dd  GDT_BASE

    ards_buf times 244 db 0
    ards_nr  dw 0		      

loader_start: 

;int 15h eax = 0000E820h ,edx = 534D4150h获取内存布局
    xor ebx, ebx		   
    mov edx, 0x534d4150	  
    mov di, ards_buf	
   
.e820_mem_get_loop:	   
    mov eax, 0x0000e820
    mov ecx, 20		      
    int 0x15
    jc .e820_failed_so_try_e801   
    add di, cx		      
    inc word [ards_nr]	      
    cmp ebx, 0		      
    jnz .e820_mem_get_loop

    mov cx,  [ards_nr]
    mov ebx, ards_buf 
    xor edx, edx	

.find_max_mem_area:	    
    mov eax, [ebx]	 
    add eax, [ebx+8]	  
    add ebx, 20		 
    cmp edx, eax		 
    jge .next_ards
    mov edx, eax	

.next_ards:
    loop .find_max_mem_area
    jmp .mem_get_ok

;  int 15h ax = E801h获取内存大小
.e820_failed_so_try_e801:
    mov ax,  0xe801
    int 0x15
    jc .e801_failed_so_try88 

    mov cx,  0x400
    mul cx 
    shl edx, 16
    and eax, 0x0000FFFF
    or edx,  eax
    add edx, 0x100000
    mov esi, edx	     

    xor eax, eax
    mov ax,  bx		
    mov ecx, 0x10000	
    mul ecx	
    add esi, eax	
    mov edx, esi	
    jmp .mem_get_ok

;采用15h中断号
.e801_failed_so_try88: 
    mov  ah, 0x88
    int  0x15
    jc .error_hlt
    and eax, 0x0000FFFF
        
    mov cx,  0x400  
    mul cx
    shl edx, 16
    or edx,  eax	     
    add edx, 0x100000  

.mem_get_ok:
    mov [total_mem_bytes], edx	 ;存入total_mem_bytes


;进入保护模式:
;1 打开A20
;2 加载gdt
;3 将cr0的pe位置1

    ;打开A20
    in al, 0x92
    or al, 0000_0010B
    out 0x92, al

    ;加载GDT
    lgdt [gdt_ptr]

    mov eax, cr0
    or eax, 0x00000001
    mov cr0, eax

    jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响

.error_hlt:
    hlt

[bits 32]
p_mode_start:

    mov ax, SELECTOR_DATA
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov esp,LOADER_STACK_TOP
    mov ax, SELECTOR_VIDEO
    mov gs, ax

    ;加载内核
    mov eax, KERNEL_START_SECTOR
    mov ebx, KERNEL_BIN_BASE_ADDR
    mov ecx, 200
    call rd_disk_m_32

    ;开启分页机制三步:设置页目录表和页表、把页目录地址给cr3、设置cr0的PG位为0
    
    call setup_page

    sgdt [gdt_ptr]

    ;更新gdt描述符中视频段描述的段基址，以及栈指针
    mov ebx, [gdt_ptr + 2]
    or dword [ebx + 0x18 + 4], 0xc0000000
    add dword [gdt_ptr + 2], 0xc0000000
    add esp, 0xc0000000

    mov eax, PAGE_DIR_TABLE_POS
    mov cr3, eax

    mov eax, cr0
    or eax, 0x80000000
    mov cr0, eax

    lgdt [gdt_ptr]
    
    call kernel_init

    mov esp, 0xc009f00

    jmp KERNEL_ENTRY_POINT  ;0x1500

;初始内核，将kernel.bin的segment拷贝到对应的地址
kernel_init:
    xor eax, eax
    xor ebx, ebx
    xor ecx, ecx
    xor edx, edx

    mov dx, [KERNEL_BIN_BASE_ADDR + 42]
    mov ebx, [KERNEL_BIN_BASE_ADDR + 28]

    add ebx, KERNEL_BIN_BASE_ADDR
    mov cx, [KERNEL_BIN_BASE_ADDR + 44]

.each_segment:
    cmp byte [ebx + 0], PT_NULL
    je .PTNULL
    push dword [ebx + 16]
    mov eax, [ebx + 4]
    add eax, KERNEL_BIN_BASE_ADDR
    push eax
    push dword [ebx + 8]
    call mem_cpy
    add esp, 12

.PTNULL:   
    add ebx, edx
    loop .each_segment
    ret

;按字节进行拷贝，栈中三个参数dst, src, size
mem_cpy:		      
    cld
    push ebp
    mov ebp, esp
    push ecx		  
    mov edi, [ebp + 8]	   ; dst
    mov esi, [ebp + 12]	   ; src
    mov ecx, [ebp + 16]	   ; size
    rep movsb		       ; 逐字节拷贝

    ;恢复环境
    pop ecx		
    pop ebp
    ret

;创建页目录和页表的函数
setup_page:

    ;把页目录清0
    mov ecx, 4096
    mov esi, 0
.clear_page_dir:
    mov byte [PAGE_DIR_TABLE_POS + esi], 0
    inc esi
    loop .clear_page_dir ;每次循环ecx中计数器减1，直到0

;开始创建页目录项
.create_pde:
    mov eax, PAGE_DIR_TABLE_POS
    add eax, 0x1000
    mov ebx, eax

    ;第0个和第768项指向第一个页表
    or eax, PG_US_U | PG_RW_W | PG_P
    mov [PAGE_DIR_TABLE_POS + 0x0], eax
    mov [PAGE_DIR_TABLE_POS + 0xc00], eax

    sub eax, 0x1000
    mov [PAGE_DIR_TABLE_POS + 4092], eax

    mov ecx, 256
    mov esi, 0
    mov edx, PG_US_U | PG_RW_W | PG_P

    ;第一个页表的前256项映射到低地址1MB
.create_pte:
    mov [ebx + esi*4], edx
    add edx, 4096
    inc esi
    loop .create_pte

    ;第769项及以后都依次指向第2个页表及以后，这1G属于内核
    mov eax, PAGE_DIR_TABLE_POS
    add eax, 0x2000
    or eax, PG_US_U | PG_RW_W | PG_P
    mov ebx, PAGE_DIR_TABLE_POS
    mov ecx, 254
    mov esi, 769
.create_kernel_pde:
    mov [ebx + esi*4], eax
    inc esi
    add eax, 0x1000
    loop .create_kernel_pde
    ret

;32位保护模式下读取硬盘n个扇区
rd_disk_m_32:	   
; eax=LBA扇区号
; ebx=将数据写入的内存地址
; ecx=读入的扇区数
    mov esi,eax
    mov di,cx


    mov dx,0x1f2
    mov al,cl
    out dx,al      ;读取的扇区数

    mov eax,esi

    mov dx,0x1f3                       
    out dx,al                          

    mov cl,8
    shr eax,cl
    mov dx,0x1f4
    out dx,al

    shr eax,cl
    mov dx,0x1f5
    out dx,al

    shr eax,cl
    and al,0x0f	
    or al,0xe0
    mov dx,0x1f6
    out dx,al

    mov dx,0x1f7
    mov al,0x20                        
    out dx,al


.not_ready:
    nop
    in al,dx
    and al,0x88	
    cmp al,0x08
    jnz .not_ready

    mov ax, di

    mov dx, 256	 
    mul dx
    mov cx, ax	   
    mov dx, 0x1f0
.go_on_read:
    in ax,dx		
    mov [ebx], ax
    add ebx, 2
        
    loop .go_on_read
    ret
